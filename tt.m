% function [ labels, featureData] = detectWarpAndWeftByOpt( initScoreImg,smoothedLabel)% function [ labels, featureData] = detectWarpAndWeftByOpt( initScoreImg,smoothedLabel)function [ labels, featureData, outs] = detectWarpAndWeftByOpt( initScoreImg,smoothedLabel)%UNTITLED5 崯??帵桳?崯敓悢揑揈梫%   initScoreImg should be the probility with the range (0 ~ 255), %   and should be integer[rows,cols] = size(initScoreImg);
 edges = getLabelImgEdges(1-smoothedLabel); %[weftWidth,warpWidth,~] = getParamOfEdges(edges); [weftWidth,warpWidth,intervals] = getParamOfEdges(edges);
 emptyFlag = 0;    if (isnan(warpWidth) & (~isnan(weftWidth)))...        | (isempty(warpWidth) & (~isempty(weftWidth)))%             warpWidth = 3;         if size(weftWidth,1)<=edges.imageRows*1./2            warpWidth = cols;            weftWidth = 0;            emptyFlag = 1;         else             warpWidth = intervals-weftWidth;         end%         emptyFlag = 1;    end    if (isnan(weftWidth) & (~isnan(warpWidth)))...        | (isempty(weftWidth) & (~isempty(warpWidth)))%          weftWidth = 3;             if size(warpWidth,1)<=edges.imageRows*1./2            weftWidth = cols;            warpWidth = 0;            emptyFlag = 1;         else         weftWidth = intervals-warpWidth;         end%         emptyFlag = 1;    end        if (isnan(weftWidth) & isnan(warpWidth))...            |(isempty(warpWidth) & isempty(weftWidth))%          warpWidth = 3;%          weftWidth = 3;                  warpWidth = cols;         weftWidth = 0;        emptyFlag = 1;    end
    if emptyFlag == 0         meanWeftWidth = getMeanByMostProb(weftWidth,0.41);         meanWarpWidth = getMeanByMostProb(warpWidth,0.41);
         if ( isnan(meanWeftWidth))             meanWeftWidth = 3;         end          if ( isnan(meanWarpWidth))             meanWarpWidth = 3;         end
         [interval,offsets,~] = getDataParamByFFT2(initScoreImg)    else       interval = 0 ;    end
 if interval == 0    min_weft_width = max(mean(weftWidth) * 0.7, min(weftWidth));    max_weft_width = max(weftWidth);    min_warp_width = max(mean(warpWidth) * 0.7, min(warpWidth));    max_warp_width = max(warpWidth);    %     min_interval = min_weft_width + min_warp_width;    max_interval = max_weft_width + max_warp_width;    %     interval = meanWeftWidth + meanWarpWidth;%            min_offset = 2;%     max_offset = interval - 2;%     %       if max_interval<4        max_offset = max(max_interval,4);    else    max_offset = max_interval - 2;    end%     if ( meanWeftWidth <= meanWarpWidth)%         min_width = min_weft_width;%         max_width = max_weft_width;%         isWeft = true;%     else%         min_width = min_warp_width;%         max_width = max_warp_width;%         isWeft = false;%     end    %     ObjectiveFunction = @(x) parameterized_objective(x,initScoreImg,interval,isWeft);%    opts = optimoptions(@particleswarm,'Display','iter','SwarmSize',200);    ObjectiveFunction = @(x) parameterized_objective_4(x,initScoreImg);    LB = [0, min_offset, min_weft_width,min_warp_width];   % Lower bound%     if interval < max_width%         max_width = interval;%     end    UB = [max_interval, max_offset, max_weft_width,max_warp_width];  % Upper bound%     MaxNum = 7;%     initSwarm = get_initSwarm(MaxNum, LB, UB); % MaxNum = 7%     [initSwarm,swarm_size] = get_initSwarm_Equal(2000, LB, UB);     %[initSwarm,swarm_size] = get_initSwarm_Equal(500, LB, UB);     [initSwarm,swarm_size] = get_initSwarm_Equal(300, LB, UB);
            opts = optimoptions(@particleswarm,...        'Display','iter',...        'SwarmSize',swarm_size,...        'UseParallel',false,...        'InitialSwarm', initSwarm);        [x,fval] = particleswarm(ObjectiveFunction,4,LB,UB,opts);     p(1) = x(1);    p(2) = x(2);    p(3) = x(3);    p(4) = x(4);        emptyFlag = 0; else
     min_offset = 2;     max_offset = interval - 2;
     if ~isempty(offsets)        if (meanWeftWidth < 0.25 * interval && meanWeftWidth < 6) ...                || ( meanWarpWidth <0.25 * interval  && meanWarpWidth < 6)            min_offset = max(2,min(offsets));             max_offset = min(interval - 2,max(offsets));         end     end
     if ( meanWeftWidth < meanWarpWidth * 0.25 )        min_weft_width = max(3,meanWeftWidth);        max_weft_width = meanWarpWidth;        isWeft = true;     elseif (meanWarpWidth < meanWeftWidth * 0.25)        min_weft_width = meanWarpWidth;        max_weft_width = interval - max(3,meanWarpWidth);         isWeft = false;     else         min_weft_width = 3;         max_weft_width = interval - 3;         isWeft = true;     end
    if ( isnan(min_offset) || ...            isnan(interval)  || ...            isnan(max_offset)  || ...            isnan(min_weft_width)  || ...            isnan(max_weft_width)  )        labels = smoothedLabel;        p(1) = 0;        p(3) = weftWidth;        p(4) = warpWidth;        p(2) = 0;        emptyFlag = 1;%         return;%     end    else    if max_offset < min_offset        max_offset = min_offset;    end    if max_weft_width < min_weft_width        max_weft_width = min_weft_width;    end    ObjectiveFunction = @(x) parameterized_objective(x,initScoreImg,interval,isWeft);%    opts = optimoptions(@particleswarm,'Display','iter','SwarmSize',200);    LB = [0 min_offset  min_weft_width];   % Lower bound    if interval < max_weft_width        %max_weft_width = interval;  interval = max_weft_width;    end    UB = [interval,max_offset,max_weft_width];  % Upper bound%     MaxNum = 4;%     initSwarm = get_initSwarm(MaxNum, LB, UB); % MaxNum = 7    [initSwarm,swarm_size] = get_initSwarm_Equal(200, LB, UB);    opts = optimoptions(@particleswarm,...        'Display','iter',...        'SwarmSize',swarm_size,...        'UseParallel',false,...        'InitialSwarm', initSwarm);       [x,fval] = particleswarm(ObjectiveFunction,3,LB,UB,opts);     p(1) = x(1);    p(2) = x(2);    if isWeft        p(3) = x(3);        if interval ~= 0            p(4) = interval - x(3);        else            p(4) = x(4);        end    else        p(4) = x(3);        if interval ~= 0            p(3) = interval - x(3);        else            p(3) = x(4);        end    end
 end end
% x%fval                   %x3:weft width in every line -> not the weft height%x4:warp width in every line -> may be several warp%x1:start point of the first line -> from 0%x2:offset of each line's start point 
    weftW = p(3);    warpW = p(4);    outs(1) = weftW; %% 测试，到出数据到excel    outs(2) = warpW;    %outs(3) = fval;    if isnan(outs)        outs(3) = 0;    else        outs(3) = fval;    end            oneCircleW = weftW + warpW;    offset = p(2);        outs(4) = offset/(weftW*warpW);        if isnan(offset)        outs(5) = 0;    else        outs(5) = offset;    end        featureData = [oneCircleW, weftW, weftW/oneCircleW, ...         min(offset,oneCircleW-offset), min(offset,oneCircleW-offset)/oneCircleW];     % %     save2excel_myData_xlsx(oneCircleW, weftW, weftW/oneCircleW, ...%         min(offset,oneCircleW-offset),min(offset,oneCircleW-offset)/oneCircleW );%     labels = [0 1 2];%     featureData = [weftW, warpW, startP, offset, oneCircleW];%     return;%     p%     rows%     cols    if emptyFlag == 0        labels = buildImageByParams(p,rows,cols);    end
    optWarpArea  = sum(sum( labels,2)) ;    optWarpArea = optWarpArea/(rows*cols);        initWarpArea  = sum(sum( initScoreImg > 127 ,2)) ;    initWarpArea = initWarpArea/(rows*cols);
    if isnan(optWarpArea)        outs(6) = 1;    else        outs(6) = optWarpArea;    end        if isnan(initWarpArea)        outs(7) = 1;    else        outs(7) = initWarpArea;    end    end
% 20170926function save2excel_myData_xlsx(weftW, warpW, startP, offset, oneCircleW)
Data=[weftW, warpW, startP, offset, oneCircleW];if~exist('FeiMiJiData.xlsx','file')    xlswrite('FeiMiJiData.xlsx',Data,1,'B1');else    [tmp1,tmp2,tmpRaw]=xlsread('FeiMiJiData.xlsx');    if size(tmp1,1)==0&&size(tmp2,1)==0 %是否是空文档        mRowRange='1';    else        mRowRange=num2str(size(tmpRaw,1));    end    xlswrite('FeiMiJiData.xlsx',Data,1,['B' mRowRange]);endend
function [c, ceq] = simple_constraint(x)    c = [x(1) - x(3) - x(4);        x(2) - x(3) - x(4)];    ceq = [];end
function y = parameterized_objective( x, initScore,interval,isWeft)    [rows,cols] = size(initScore);    p(1) = x(1);    p(2) = x(2);        if isWeft        p(3) = x(3);        if interval ~= 0            p(4) = max(3,interval - x(3));        else            p(4) = x(4);        end    else        p(4) = x(3);        if interval ~= 0            p(3) = max(3,interval - x(3));        else            p(3) = x(4);        end            end            labels = buildImageByParams(p,rows,cols);    labelS = initScore > 127;    %     y = sum(sum(labels ~= labelS));        y = 0;    for i = 1 : rows        for j = 1 : cols            if ( labels(i,j) ~= labelS(i,j))                y = y + abs(initScore(i,j) - 127);            else                y = y - abs(initScore(i,j) - 127);            end        end    end    endfunction y = parameterized_objective_4( x, initScore)    [rows,cols] = size(initScore);    p(1) = x(1);    p(2) = x(2);    p(3) = x(3);    p(4) = x(4);      labels = buildImageByParams(p,rows,cols);    labelS = initScore > 127;    %     y = sum(sum(labels ~= labelS));        y = 0;    for i = 1 : rows        for j = 1 : cols            if ( labels(i,j) ~= labelS(i,j))                y = y + abs(initScore(i,j) - 127);            else                y = y - abs(initScore(i,j) - 127);            end        end    end    end
function labels = buildImageByParams(x,rows,cols)    labels = zeros(rows,cols);        weftWidth = x(3);    warpWidth = x(4);    oneCircleWidth = weftWidth + warpWidth;        if weftWidth <= 0        labels = ones(rows,cols)*255;        return;    end    if warpWidth <= 0        return;    end        startPoint = floor(x(1));    offset = x(2);
    %build a sample line with 2xCols    sampleLine = zeros(1,cols*3);    n = floor(cols*3/oneCircleWidth);    for i = 1 : n        s = (i - 1)*oneCircleWidth + 1;        sampleLine( round(s) : round(s + weftWidth - 1) ) =  0;        sampleLine( round(s + weftWidth) :round(s+oneCircleWidth - 1)) =  1;    end
    for i = 1 : rows        s =  mod(  startPoint + round(( i - 1 ) * offset), round(oneCircleWidth) ) + 1;        labels(i,:) = sampleLine(round(s):round(s+cols-1));                  end    end
function [weftWidth,warpWidth,intervals] = getParamOfEdges(edges)    weftWidth = zeros(sum(edges.edgeCount),1);    warpWidth = weftWidth;    weftCount = 0;    warpCount = 0;    intervals = zeros(sum(edges.edgeCount),1);    intervalsCount = 0;                startDis =  zeros(sum(edges.edgeCount),1);        endDis =   zeros(sum(edges.edgeCount),1);            for i = 1 :  edges.imageRows        for j = 2 : edges.edgeCount(i)              if(j == 2)                startDis(i) = edges.edgePoint(i,j-1,1);            end            if(j == edges.edgeCount(i))                endDis(i) = edges.imageCols - edges.edgePoint(i,j,1);            end                        if ( edges.edgePoint(i,j,2) == 0 )                warpCount = warpCount + 1;                warpWidth(warpCount) = edges.edgePoint(i,j,1) - edges.edgePoint(i,j-1,1);            else                weftCount = weftCount + 1;                weftWidth(weftCount) = edges.edgePoint(i,j,1) - edges.edgePoint(i,j-1,1);            end                        if ( j > 2 )                intervalsCount = intervalsCount+ 1;                intervals(intervalsCount) = edges.edgePoint(i,j,1) - edges.edgePoint(i,j-2,1);            end        end    end        weftWidth = weftWidth(1:weftCount);    warpWidth = warpWidth(1:warpCount);    intervals = intervals(1:intervalsCount);        if weftCount == 0 && warpCount ~= 0         intervals = max(max([startDis,endDis]))+max(warpWidth);    end    if weftCount ~= 0 && warpCount == 0          intervals = max(max([startDis,endDis]))+max(weftWidth);    end    end
function  [edges]  = getLabelImgEdges( labels)%labels should be 0,1 image%1:weft,0:warp    [rows,cols] = size(labels);
    edges.imageRows = rows;    edges.imageCols = cols;            %edgePoint(:,:,1) : the col index of the point        %edgePoint(:,:,2) : the type of the point,0:weft's left edge,1:weft's right edge        edges.edgePoint = zeros(rows,floor(cols/2),2);        edges.edgeCount = zeros(rows,1);        edges.intervals  = zeros(rows * floor(cols/2),1);        edges.intervalsCount = 0;                for i = 1: rows        for j = 2: cols            if labels(i,j) ~= labels(i,j-1)                edges.edgeCount(i) = edges.edgeCount(i)  + 1;                edges.edgePoint(i,edges.edgeCount(i),1) = j;                                if (labels(i,j) == 1)                    %weft's left edge                    edges.edgePoint(i,edges.edgeCount(i),2) = 0;                else                    %weft's right edge                    edges.edgePoint(i,edges.edgeCount(i),2) = 1;                end                                if ( edges.edgeCount(i)  > 2 )                    edges.intervalsCount = edges.intervalsCount + 1;                    edges.intervals(edges.intervalsCount) = ...                        j - edges.edgePoint(i,edges.edgeCount(i)-2,1);                end            end        end        endend
function initSwarm = get_initSwarm(MaxNum, LB, UB)    initValue = zeros(MaxNum,3);    initSwarm = zeros(MaxNum^3,3);
    i1 = (UB(1) - LB(1))/(MaxNum-1);    i2 = (UB(2) - LB(2))/(MaxNum-1);    i3 = (UB(3) - LB(3))/(MaxNum-1);    for i = 1:MaxNum       initValue(i,1) = i1 * (i-1) + LB(1);       initValue(i,2) = i2 * (i-1) + LB(2);       initValue(i,3) = i3 * (i-1) + LB(3);    end    initValue(MaxNum,1) = min(UB(1),initValue(MaxNum,1));    initValue(MaxNum,2) = min(UB(2),initValue(MaxNum,2));    initValue(MaxNum,3) = min(UB(3),initValue(MaxNum,3));
    for i = 1:MaxNum       for j = 1:MaxNum         for k = 1:MaxNum            initSwarm((i-1)*MaxNum*MaxNum+(j-1)*MaxNum+k,1) = initValue(i,1);            initSwarm((i-1)*MaxNum*MaxNum+(j-1)*MaxNum+k,2) = initValue(j,2);            initSwarm((i-1)*MaxNum*MaxNum+(j-1)*MaxNum+k,3) = initValue(k,3);        end       end    end        end
function [initSwarm,swarm_size] = get_initSwarm_Equal(initSize, LB, UB)
        param_num = length(LB);        total_range = 0;        for i = 1 : param_num        total_range = total_range + UB(i) - LB(i);    end            total_size = ceil(nthroot(initSize,param_num)) * param_num;    average_step = max(1,total_range / total_size);        swarm_dim_size = zeros(param_num,1);    swarm_size = 1;    while  average_step >= 1        swarm_size = 1;        for i = 1:param_num            swarm_dim_size(i) = 1 + ceil((UB(i) - LB(i)) / average_step);            swarm_size = swarm_size * swarm_dim_size(i);        end                if ( swarm_size >=  initSize )            break;        end        average_step = average_step - 1;    end        if swarm_size < initSize         initSwarm = [];        return;    end        initValue = zeros(max(swarm_dim_size),param_num);       for i = 1 : param_num        for j = 1 : swarm_dim_size(i)            initValue(j,i) = min( (j-1)*average_step + LB(i),UB(i));        end    end            initSwarm = zeros(swarm_size,param_num);    loop_size = swarm_size;    for i = 1 : param_num        loop_size = loop_size / swarm_dim_size(i);        for k = 1 : swarm_size / (loop_size * swarm_dim_size(i))            offset = (k-1) * loop_size * swarm_dim_size(i);            for j = 1 : swarm_dim_size(i)                initSwarm(offset + (j-1)*loop_size+1: offset + j*loop_size, ...                                        i) = initValue(j,i);            end        end    end        end
